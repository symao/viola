/**
 * Copyright (c) 2016-2023 shuyuanmao <maoshuyuan123@gmail.com>. All rights reserved.
 * @author shuyuanmao <maoshuyuan123@gmail.com>
 * @date 2023-02-07 15:07
 * @details
 */
#include "vs_mesh.h"
#include <fstream>
#include "vs_basic.h"

#define ENABLE_HAPPLY 1
#if ENABLE_HAPPLY
#include <mesh_io/happly.h>
#endif

namespace vs {

bool MeshData::readObj(const char* file) {
  std::ifstream fin(file);
  if (!fin.is_open()) return false;
  vertices.clear();
  polygons.clear();
  std::string line;
  while (getline(fin, line)) {
    if (line.length() < 2) continue;
    if (startswith(line, "v ")) {
      double x, y, z;
      sscanf(line.c_str(), "v %lf %lf %lf", &x, &y, &z);
      vertices.emplace_back(x, y, z);
    } else if (startswith(line, "f ")) {
      std::stringstream ss(line.substr(2));
      std::string t;
      Polygon ids;
      while (getline(ss, t, ' ')) {
        if (t.length() == 0) continue;
        int v, vt, vn;
        sscanf(t.c_str(), "%d/%d/%d", &v, &vt, &vn);
        ids.push_back(v - 1);
      }
      polygons.push_back(ids);
    }
  }
  return true;
}

bool MeshData::writeObj(const char* file) const {
#ifdef WIN32
  FILE* fp;
  if (fopen_s(&fp, file, "w") != 0) return false;
#else
  FILE* fp = fopen(file, "w");
  if (!fp) return false;
#endif
  // write header
  fprintf(fp,
          "####\n"
          "# OBJ File Generated by MeshData::writeObj()\n"
          "# Vertices: %d\n"
          "# Faces: %d\n"
          "####\n",
          VS_INT(vertices.size()), VS_INT(polygons.size()));
  // write vertices
  for (const auto& p : vertices) fprintf(fp, "v %f %f %f\n", p.x, p.y, p.z);
  for (const auto& n : normals) fprintf(fp, "vn %f %f %f\n", n[0], n[1], n[2]);

  // write faces
  char str[512] = {0};
  for (const auto& p : polygons) {
    int idx = 0;
    idx += snprintf(str + idx, 512 - idx, "f");
    for (auto i : p) idx += snprintf(str + idx, 512 - idx, " %d", static_cast<int>(i + 1));
    idx += snprintf(str + idx, 512 - idx, "\n");
    fprintf(fp, "%s", str);
  }
  // close file
  fclose(fp);
  return true;
}

#if ENABLE_HAPPLY
bool MeshData::readPly(const char* file) {
  vertices.clear();
  colors.clear();
  polygons.clear();
  normals.clear();

  happly::PLYData ply(file);
  auto pos_list = ply.getVertexPositions();
  auto face_list = ply.getFaceIndices();

  if (!pos_list.empty()) {
    vertices.reserve(pos_list.size());
    for (const auto& p : pos_list) vertices.emplace_back(p[0], p[1], p[2]);
  }
  if (!face_list.empty()) {
    polygons = face_list;
  }
  if (ply.getElement("vertex").hasProperty("red") && ply.getElement("vertex").hasProperty("green") &&
      ply.getElement("vertex").hasProperty("blue")) {
    auto color_list = ply.getVertexColors();
    colors.reserve(color_list.size());
    for (const auto& c : color_list) colors.emplace_back(c[2], c[1], c[0]);
  }
  return !vertices.empty();
}

bool MeshData::writePly(const char* file) const {
  if (!vertices.empty()) return false;
  happly::PLYData ply;
  std::vector<std::array<double, 3>> pos_list;
  vecMapping(vertices, pos_list, [](const Vertex& v) { return std::array<double, 3>({v.x, v.y, v.z}); });
  ply.addVertexPositions(pos_list);

  if (!colors.empty()) {
    std::vector<std::array<double, 3>> color_list;
    vecMapping(colors, color_list, [](const Color& c) {
      return std::array<double, 3>({VS_DOUBLE(c[2]) / 255.0, VS_DOUBLE(c[1]) / 255.0, VS_DOUBLE(c[0]) / 255.0});
    });
    ply.addVertexColors(color_list);
  }
  if (!polygons.empty()) {
    auto face_list = polygons;
    ply.addFaceIndices(face_list);
  }
  ply.write(file);
  return true;
}

#else
bool MeshData::readPly(const char* file) {
  // todo
  return false;
}

bool MeshData::writePly(const char* file) const {
#ifdef WIN32
  FILE* fp;
  if (fopen_s(&fp, file, "w") != 0) return false;
#else
  FILE* fp = fopen(file, "w");
  if (!fp) return false;
#endif
  // write header
  fprintf(fp,
          "ply\n"
          "format ascii 1.0\n"
          "element vertex %d\n"
          "property float x\n"
          "property float y\n"
          "property float z\n",
          VS_INT(vertices.size()));
  if (!colors.empty())
    fprintf(fp,
            "property uchar red\n"
            "property uchar green\n"
            "property uchar blue\n");
  if (!polygons.empty())
    fprintf(fp,
            "element face %d\n"
            "property list uchar int vertex_index\n",
            VS_INT(polygons.size()));
  fprintf(fp, "end_header\n");
  // write vertices
  if (colors.empty()) {
    for (const auto& p : vertices) fprintf(fp, "%f %f %f\n", p.x, p.y, p.z);
  } else {
    auto color = colors[0];
    for (size_t i = 0; i < vertices.size(); i++) {
      const auto& p = vertices[i];
      if (i < colors.size()) color = colors[i];
      fprintf(fp, "%f %f %f %d %d %d\n", p.x, p.y, p.z, color[0], color[1], color[2]);
    }
  }
  // write faces
  for (const auto& ids : polygons) {
    fprintf(fp, "%d", VS_INT(ids.size()));
    for (auto i : ids) fprintf(fp, " %d", static_cast<int>(i));
    fprintf(fp, "\n");
  }
  // close file
  fclose(fp);
  return true;
}
#endif
}  // namespace vs