/**
 * Copyright (c) 2016-2023 shuyuanmao <maoshuyuan123@gmail.com>. All rights reserved.
 * @author shuyuanmao <maoshuyuan123@gmail.com>
 * @date 2023-02-07 15:07
 * @details
 */
#include "vs_mesh.h"
#include <fstream>
#include "vs_basic.h"

namespace vs {

std::vector<int> MeshData::toVizPoly(const std::vector<std::vector<int>>& polys) {
  std::vector<int> res;
  for (const auto& poly : polys) {
    res.push_back(poly.size());
    for (const auto& i : poly) res.push_back(i);
  }
  return res;
}

bool MeshData::readObj(const char* file) {
  std::ifstream fin(file);
  if (!fin.is_open()) return false;
  vertices.clear();
  polygons.clear();
  std::string line;
  while (getline(fin, line)) {
    if (line.length() < 2) continue;
    if (vs::startswith(line, "v ")) {
      double x, y, z;
      sscanf(line.c_str(), "v %lf %lf %lf", &x, &y, &z);
      vertices.emplace_back(x, y, z);
    } else if (vs::startswith(line, "f ")) {
      std::stringstream ss(line.substr(2));
      std::string t;
      std::vector<int> ids;
      while (getline(ss, t, ' ')) {
        if (t.length() == 0) continue;
        int v, vt, vn;
        sscanf(t.c_str(), "%d/%d/%d", &v, &vt, &vn);
        ids.push_back(v - 1);
      }
      polygons.push_back(ids);
    }
  }
  return true;
}

bool MeshData::writeObj(const char* file) {
#ifdef WIN32
  FILE* fp;
  if (fopen_s(&fp, file, "w") != 0) return false;
#else
  FILE* fp = fopen(file, "w");
  if (!fp) return false;
#endif
  // write header
  fprintf(fp,
          "####\n"
          "# OBJ File Generated by vs::MeshData::writeObj()\n"
          "# Vertices: %d\n"
          "# Faces: %d\n"
          "####\n",
          VS_INT(vertices.size()), VS_INT(polygons.size()));
  // write vertices
  for (const auto& p : vertices) fprintf(fp, "v %f %f %f\n", p.x, p.y, p.z);
  for (const auto& n : normals) fprintf(fp, "vn %f %f %f\n", n[0], n[1], n[2]);

  // write faces
  char str[512] = {0};
  for (const auto& p : polygons) {
    int idx = 0;
    idx += snprintf(str + idx, 512 - idx, "f");
    for (auto i : p) idx += snprintf(str + idx, 512 - idx, " %d", i + 1);
    idx += snprintf(str + idx, 512 - idx, "\n");
    fprintf(fp, "%s", str);
  }
  // close file
  fclose(fp);
  return true;
}

bool MeshData::readPly(const char* file) {
  // todo
  return false;
}

bool MeshData::writePly(const char* file) {
#ifdef WIN32
  FILE* fp;
  if (fopen_s(&fp, file, "w") != 0) return false;
#else
  FILE* fp = fopen(file, "w");
  if (!fp) return false;
#endif
  // write header
  fprintf(fp,
          "ply\n"
          "format ascii 1.0\n"
          "element vertex %d\n"
          "property float x\n"
          "property float y\n"
          "property float z\n",
          VS_INT(vertices.size()));
  if (!colors.empty())
    fprintf(fp,
            "property uchar red\n"
            "property uchar green\n"
            "property uchar blue\n");
  if (!polygons.empty())
    fprintf(fp,
            "element face %d\n"
            "property list uchar int vertex_index\n",
            VS_INT(polygons.size()));
  fprintf(fp, "end_header\n");
  // write vertices
  if (colors.empty()) {
    for (const auto& p : vertices) fprintf(fp, "%f %f %f\n", p.x, p.y, p.z);
  } else {
    auto color = colors[0];
    for (size_t i = 0; i < vertices.size(); i++) {
      const auto& p = vertices[i];
      if (i < colors.size()) color = colors[i];
      fprintf(fp, "%f %f %f %d %d %d\n", p.x, p.y, p.z, color[0], color[1], color[2]);
    }
  }
  // write faces
  for (const auto& ids : polygons) {
    fprintf(fp, "%d", VS_INT(ids.size()));
    for (auto i : ids) fprintf(fp, " %d", i);
    fprintf(fp, "\n");
  }
  // close file
  fclose(fp);
  return true;
}

}  // namespace vs